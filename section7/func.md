
## 함수
	//함수
	//선언 : func 키워드로 선언

## 함수 선언의 방법 
- func 함수명(매개변수) (반환타입 or 반환 값 변수명) : 반환 값 존재
- func 함수명() (반환타입 or 반환 값 변수명) : 매개변수 없음, 반환 값 존재
- func 함수명(매개변수) : 매개변수 존재, 반환 값 없음
- 타 언어와 달리 반환 값(return value) 여러 개 가능

## 함수의 종류
- 가변 인수 함수
- defer 지연
- 

##  
- 함수(콜백)
- 참조 전달(call by reference) 
- 값 전달(call by value)

## 포인트
매개변수 다중일때, 동일한 자료형은 마지막에 자료형 한번 선언으로 가능
```multiply(x int, y int) (int, int) { //(x, y int)가능```

## 매개변수 관련
### 매개변수 선언
* 매개변수를 효율적으로 사용하기 위해 아래와 같이 ...int 형태로 사용하면 됨

```
func multiply(n ...int) int { // 매개변수 수량이 정해져있지 않으면 이렇게 가능
	tot := 1
	for _, value := range n {
		tot *= value
	}

	return tot
}
```
* 




## 함수의 재활용
- 슬라이스로 할당
```
f := []func(int, int) int{multiply, sum}
```
- 변수에 할당
- 맵에 할당

## 재귀 함수
- 프로그램이 보기 쉽고, 코드 간결, 오류 수정이 용이함 : 장점
- 코드 이해가 어렵고, 기억공간을 많이 사용, 무한루프 가능성


```

```



## 익명함수
- 함수 리터럴이라고도 부른다.


## 지연함수
- Defer를 호출한 함수가 종료되기 직전에 호출된다.
- 주로 리소스 반환, 데이터베이스 커넥션 닫기, 열린 파일 닫기, Mutex잠금 해제 
- Defer라고도 부르며, 흐름제어에 쓰인다.
- Panic, Recover 등도 지연하도록 만들어 줌
- 다른 언어에서는 Finally 등으로 사용된다.

- 스택으로 쌓인다. 선입선출
* 1~10번까지 스택으로 쌓인다면, 가장 마지막에 들어간 10부터 1순서로 빠져나온다.
```

```
*중첩함수를 쓴 경우*
`defer end()

## Closure 함수
- 익명함수 사용할 경우 함수를 변수에 할당해서 사용 가능
- 함수 안에서 함수를 선언 및 정의 가능 -> 이때 외부 함수에 선언된 변수에 접근 가능한 함수
- 함수가 선언되는 순간에 함수가 실행 될 때 실체의 외부 변수에 접근하기 위한 스냅샷
- 함수 호출 할 때 이전에 존재했던 값을 유지하기 위해 -> 함수가 종료되어도 값을 유지하기 위해 : 비동기, 누적카운트 => 무분별한 전역변수 남발 => 객체들이 메모리에 존재하므로 메모리 부족, 오버플로우 발생가능
```
func main() {

	//예제1 함수에서 함수를 리턴한다.
	cnt := increaseCnt()

	fmt.Println("ex1 : ", cnt())
	fmt.Println("ex1 : ", cnt())
	fmt.Println("ex1 : ", cnt())
	fmt.Println("ex1 : ", cnt())
	fmt.Println("ex1 : ", cnt())

}

func increaseCnt() func() int {
	n := 0 //지역변수(캡처됨)
	return func() int {
		n += 1
		return n
	}
}
```
